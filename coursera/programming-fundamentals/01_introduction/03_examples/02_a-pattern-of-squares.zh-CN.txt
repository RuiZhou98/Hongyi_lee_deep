在本视频中，我们将为 网格上蓝色和红色方块的特定图案开发一种算法。 我们将从第一步开始， 举一个问题实例。 在本例中，我选择了 N 等于三。 因此，我要做的第一件事就是 手工解决问题，而不必真正考虑自己在做什么。 也就是说，我会做对的， 但我不会试图写下我的所作所为。 完成后，我将执行第二步， 逐步写下我所做的事情。 我做的第一件事是在零、零处放一个蓝色方块。 然后我把一个红色方块放在零，一个， 另一个红色方块放在零， 二，一个蓝色方块放在零， 三，一个红色方块放在一，一， 蓝色在一， 二，红在一，三，红在二，二，二， 红在二、三，红在二 、三，最后在三、三处放一个蓝色。 现在我想概括一下这些步骤， 即编程过程的第三步。 如果我们看一下这些步骤， 我们可以看到有一些重复和计数行为， 这将有助于我们将这些步骤概括为算法。 前四个步骤的 x 等于零， 然后我们有一组三个步骤表示 x 等于 1， 一组两个步长表示 x 等于二， 最后一个步长表示 x 等于三。 因此，我们在重复一些类似的步骤，因为我们计算x从零到三。 但是我们到底做的事情各不相同。 我们把方块涂成蓝色、红 色、红色、蓝色代表x等于零或者红色、蓝色、 红色代表x等于一， 所以颜色图案是我们仍然需要弄清楚的。 此外，每个 y 坐标中有多少步也各不相同。 让我们先看看 y 坐标， 过一会儿再回到颜色上。 如果我们看一下第一组步骤，就会 看到 y 坐标从零变为三。 如果我们看第二组步骤， 我们会看到 y 坐标从一到三 ，在第三组中，从二到三。 所以看来，总的来说， 我们正在从 x 数到 3。 如果我们暂时忽略颜色， 我们可以采取这一组步骤然后说， 我们从零到三计数， 调出我们计数的数字 y， 然后在零处放一个我们稍后会弄清楚的颜色的正方形，y。 我们可以为其他每组写出类似的步骤。 现在我们可以在这些步骤中使用模式来进一步概括我们的算法。除了@@ 以粗体显示的 x 坐标外，每组步骤都相同， 而且这些步数各不相同，计数模式不错。 也就是说，我们可以说从零到三计数， 调用我们计算的每个数字 x， 对于每个数字， 我们将从 x 计数到三然后称之为 y，然后在 x，y 处放一些彩色方块。 但这只对于 N 等于三才是正确的。 我们尚未完成概括的一个线索 是，这些步骤根本不依赖于 N。 我们知道不同的 N 的模式会有所不同， 但这并未反映在我们编写的算法中。 我们需要让它更笼统。 我们怎么能做到这一点？ 我们可能会意识到这一点， 但如果我们没意识到，我们可以回过头来重复步骤一和二。 如果模式很难弄清楚， 我们可能需要多次执行第一步和第二步。 因此，举个例子，如果我们回过头来执行 N 等于一的步骤， 我们最终会得到这种模式。 当我们执行第二步时， 我们会写下这些步骤。 如果我们再次进行概括过程， 我们会看到我们想出了这些步骤。 从零到一计数， 称之为 x；从 x 计数为一，称之为 y； 然后在 x，y 处放一个某种颜色的正方形， 这与 N 等于三非常相似，只是这个数字发生了变化。 对于任何 N，我们根据示例中的模式从 0 到 N 进行计数。 现在我们有了更通用的算法。 当然，我们需要弄清楚颜色的问号是什么。 为此，我们可以回到我们的 N 等于三个示例中的颜色。 我们主要是红色方块和一些蓝色方块， 所以我们应该弄清楚正方形何时为蓝色的图案。 我把红色的丢掉了这样我们就可以用蓝色来寻找图案了。 只有四条信息，这种模式可能有点微妙。 你可能已经弄清楚了， 但如果没有，你能做什么？ 好吧，如果有更多信息，可能会更容易看见。 看着 N 等于五， 我们还有更多的蓝色方块需要考虑。 现在，你看看模式，看看你想出了什么， 这主要是你看数字和找到模式的能力。 如果我们将 x 和 y 坐标相加， 就会发现它们是零、三、 三、六、六、六、六和九。 所以这里的模式是，当 且仅当 x 加 y 是三的倍数时，我们才画一个蓝色方块。 现在我们可以回到我们的算法，指定 x 加 y 是否是三的倍数， 我们在 x, y 处放一个蓝色方块。 否则，我们在 x, y 处放一个红方块。 这个算法看起来不错， 但我们要执行第四步并对其进行测试， 如下一个视频所示。