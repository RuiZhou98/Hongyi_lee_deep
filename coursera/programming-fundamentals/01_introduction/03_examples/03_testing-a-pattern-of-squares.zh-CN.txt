在本视频中，我们将测试 网格上蓝色和红色方块图案的算法。 请记住，测试将使我们对算法更有信心， 因为泛化是编程过程中最困难的部分之一，并且 很容易出现错误，例如将本应是变量的东西保持不变。 我们需要一个可以绘制的网格， 一个用来跟踪我们在算法中的位置的箭头， 以及一个用来列出变量的方框。 让我们用 2 来表示 N 的值。我们为 x 做一个方框然后从零开始计数。 然后我们为 y 做一个方框，然后从 x 的值开始计数，这里为零。 现在，我们需要确定 x 加 y 是否是三的倍数。 确实如此，所以我们进入 if 语句并在零、零处放一个蓝色方块。 现在，y 的迭代没有更多的步骤， 所以我们继续计数 y 等于 1。 零加一不是三的倍数， 所以我们输入其他子句并在零、一处放一个红方块。 这个 y 没有其他步骤， 所以我们将计算下一个步骤。 零加二不是三的倍数， 所以我们要在零、二处放一个红方块。 我们继续计数，y 等于三。 但是我们只是从 x 到 N 进行计数，所以我们没有执行任何这些步骤。 我们继续对 x 进行计数， 所以现在，x 是 1。 我们要从 1 到 N 数然后称之为 y。 一加一不是三的倍数， 所以我们在一、一处放一个红方块。 递增 y，一加二是三的倍数， 所以我们在一、二处放一个蓝色方块。 我们已经完成了 y 的计 数，所以接下来，我们计算下一个的 x。 从二到二计数， 二加二不是三的倍数， 所以我们放一个红方块。 我们完成了 y 的计数， 所以我们对下一个 x 进行计数。 我们已经完成了 x 的计数，因为我们只想计数到 N，也就是二。 所以我们完成了计数， 我们完成了这个算法的执行。 我们已经完成了，我们找到了我们所期望的答案。 我们可以说我们的算法 至少适用于 N 等于 2。 我们对自己的算法更有信心了，因为我们已经证明它 对于至少一个 N 值是正确的，而这不是我们以前想出的。 如果我们想更加自信， 就必须对其进行更彻底的测试。 与往常一样，测试无法证明它是正确的， 它只会让我们越来越自信。