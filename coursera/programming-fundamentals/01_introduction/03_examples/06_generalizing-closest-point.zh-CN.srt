1
00:00:03,542 --> 00:00:07,630
在之前的视频中，我们仔细地写下了

2
00:00:07,630 --> 00:00:09,740
手工处理特定案例时所遵循的步骤。

3
00:00:09,740 --> 00:00:13,650
在本视频中，我们概括了寻找最近点的步骤。

4
00:00:14,780 --> 00:00:17,890
看看我们的步骤，其中一些是相似的，但

5
00:00:17,890 --> 00:00:20,240
我们需要让它们匹配。

6
00:00:20,240 --> 00:00:23,420
每个彩色方框都包含相似的步骤。

7
00:00:23,420 --> 00:00:26,550
首先是计算，然后是比较。

8
00:00:26,550 --> 00:00:29,690
我们还有一些只有有时才做的步骤，

9
00:00:29,690 --> 00:00:32,230
我们需要弄清楚我们在什么条件下执行这些步骤。

10
00:00:33,520 --> 00:00:36,740
我们还有一些步骤只能在开头和结尾做，

11
00:00:36,740 --> 00:00:39,990
我们需要对这些步骤中的数字进行概括。

12
00:00:39,990 --> 00:00:44,060
因此，让我们做的第一件事就是让这些相似的东西相匹配。

13
00:00:44,060 --> 00:00:47,562
为什么在这里计算 9 平方加 6 平方，

14
00:00:47,562 --> 00:00:50,680
接下来计算 7 平方加上 -1 平方等等。

15
00:00:52,330 --> 00:00:58,580
如果我们看一下我们的图片，9 来自 delta x，6 来自增量 y。

16
00:00:58,580 --> 00:01:03,730
集合 S 中的点 10、5 和 1、-1、点 p 之间的差异。

17
00:01:05,100 --> 00:01:09,460
所有这些其他数字也是如此，

18
00:01:09,460 --> 00:01:12,550
点 s 和 p 之间的 x 和 y 差异。

19
00:01:12,550 --> 00:01:18,660
所以我们可以重写所有这些步骤，让点 S1、

20
00:01:18,660 --> 00:01:21,110
S2 等，直到 S6。当@@

21
00:01:22,210 --> 00:01:26,610
我们进入起始步骤时，我们将第一个点称为 s0。

22
00:01:26,610 --> 00:01:28,780
程序员通常喜欢从 0 开始计数。

23
00:01:28,780 --> 00:01:36,900
第一个替换给我们 s1 的 x-P 的 x 数量平方 + s1 的

24
00:01:36,900 --> 00:01:41,860
y-P 的 y 数量平方，然后是整个事物的平方根。

25
00:01:43,520 --> 00:01:48,470
现在，这个计算的结果并不总是10.82或7.07，

26
00:01:48,470 --> 00:01:53,790
所以我们应该给它们起个名字，比如当前距离。

27
00:01:53,790 --> 00:01:56,870
但是当我们这样做时，

28
00:01:56,870 --> 00:02:00,910
我们必须跟踪每次使用这个数字并更新它们。

29
00:02:00,910 --> 00:02:05,510
也就是说，如果我们将第一次出现的 10.82 更改为 currentDistance，

30
00:02:05,510 --> 00:02:10,398
那么我们需要将这条线的当前距离与 8.06 进行比较。

31
00:02:10,398 --> 00:02:14,450
但是其中一些数字是以其他方式使用的，因此

32
00:02:14,450 --> 00:02:16,170
这些数字需要不同的名称。

33
00:02:17,450 --> 00:02:21,320
在这里，我们将每次计算的值替换为 currentDistance。

34
00:02:22,320 --> 00:02:25,490
请注意，只有

35
00:02:25,490 --> 00:02:27,980
当当前距离较小时，我们才会更新最佳选择。

36
00:02:27,980 --> 00:02:30,970
这意味着我们一定一直在跟踪

37
00:02:30,970 --> 00:02:33,540
迄今为止的最佳距离，我们现在也需要对其进行更新。

38
00:02:35,030 --> 00:02:39,760
现在，当当前距离较小时，我们会更新最佳距离，

39
00:02:39,760 --> 00:02:43,509
我们可以使用最佳距离的值与将来的计算进行比较。

40
00:02:45,140 --> 00:02:52,330
让我们来看看我们计算的第一个 8.06，并考虑它发生的其他地方。

41
00:02:52,330 --> 00:02:55,830
可以像使用 S0 一样进行计算。

42
00:02:55,830 --> 00:03:00,405
由于这是我们的第一次计算，它也可能是迄今为止最好的，

43
00:03:00,405 --> 00:03:05,734
那么我们可以用 BestDistance 替换另一个实例，使步骤匹配。

44
00:03:05,734 --> 00:03:08,727
为了继续概括，让我们来看看

45
00:03:08,727 --> 00:03:11,480
最佳选择 2,7,8、-2 和 -3、-5 的重点。

46
00:03:11,480 --> 00:03:17,660
这些都是我们正在研究的具体点，因此

47
00:03:17,660 --> 00:03:21,870
我们可以用 S0、S2 和 S4 替换它们。

48
00:03:23,090 --> 00:03:26,260
回想一下，我们只

49
00:03:26,260 --> 00:03:27,370
是在当前距离较小时才更新最佳选择。

50
00:03:27,370 --> 00:03:31,440
我们可以通过包括每次比较

51
00:03:31,440 --> 00:03:34,610
当前距离和最佳距离的说明来使每个步骤都相同，但是

52
00:03:34,610 --> 00:03:37,600
只有在当前距离较小时才更新最佳距离。

53
00:03:38,810 --> 00:03:42,140
现在，我们对每个点都执行相同的步骤。

54
00:03:42,140 --> 00:03:45,010
每个彩色盒子都与其他方块相同，唯一的不同

55
00:03:45,010 --> 00:03:48,960
是我们要看的是什么，从S1、S2到S6。

56
00:03:48,960 --> 00:03:52,190
这意味着我们可以将其表达为重复，

57
00:03:52,190 --> 00:03:56,700
其中我们从 1 计数到 S 不包含的分数。

58
00:03:56,700 --> 00:03:58,220
我们将计算的每个数字称为 i，

59
00:03:58,220 --> 00:04:03,226
然后计算从 S 中第 ieth 点到 P 的距离。

60
00:04:03,226 --> 00:04:06,490
如果当前距离小于最佳距离，

61
00:04:06,490 --> 00:04:12,500
则我们会将最佳选择更新为 SI，将最佳距离更新为 SI，将最佳距离更新为当前距离。

62
00:04:12,500 --> 00:04:16,440
我们没有改变开始或结束的步骤，但

63
00:04:16,440 --> 00:04:19,790
我们应该将我们给出的观点概括为答案。

64
00:04:19,790 --> 00:04:22,920
答案并不总是-3、-5。

65
00:04:22,920 --> 00:04:24,320
我们为什么这么说？

66
00:04:25,330 --> 00:04:29,480
当我们完成计数时，答案是最佳选择，所以总的来说，

67
00:04:29,480 --> 00:04:31,130
我们会给出最佳选择的答案。

68
00:04:32,580 --> 00:04:36,390
我们唯一需要做的另一件事就是考虑一个极端情况。

69
00:04:36,390 --> 00:04:39,270
如果 S 里面有 0 分怎么办？

70
00:04:39,270 --> 00:04:42,900
在这种情况下，我们会给出不存在答案的答案。

71
00:04:42,900 --> 00:04:46,480
我们刚才研究的例子并未揭示这个极端情况，但

72
00:04:46,480 --> 00:04:48,820
它本来是通过测试得出来的。

73
00:04:48,820 --> 00:04:51,100
以 0 分为例，

74
00:04:51,100 --> 00:04:54,960
我们在计算的第一步时会遇到问题。

75
00:04:54,960 --> 00:04:58,810
因此，我们报告没有答案，请跳过所有其他步骤。

76
00:05:00,000 --> 00:05:01,370
所以这是我们的算法。

77
00:05:01,370 --> 00:05:03,210
你可以自己测试一下。

78
00:05:03,210 --> 00:05:06,530
稍后，我们将学习如何将其转换为代码。