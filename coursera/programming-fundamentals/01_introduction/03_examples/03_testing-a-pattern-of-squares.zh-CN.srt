1
00:00:02,380 --> 00:00:05,720
在本视频中，我们将测试

2
00:00:05,720 --> 00:00:08,505
网格上蓝色和红色方块图案的算法。

3
00:00:08,505 --> 00:00:12,315
请记住，测试将使我们对算法更有信心，

4
00:00:12,315 --> 00:00:16,340
因为泛化是编程过程中最困难的部分之一，并且

5
00:00:16,340 --> 00:00:21,110
很容易出现错误，例如将本应是变量的东西保持不变。

6
00:00:21,110 --> 00:00:22,835
我们需要一个可以绘制的网格，

7
00:00:22,835 --> 00:00:26,102
一个用来跟踪我们在算法中的位置的箭头，

8
00:00:26,102 --> 00:00:28,621
以及一个用来列出变量的方框。

9
00:00:28,621 --> 00:00:35,350
让我们用 2 来表示 N 的值。我们为 x 做一个方框然后从零开始计数。

10
00:00:35,350 --> 00:00:39,930
然后我们为 y 做一个方框，然后从 x 的值开始计数，这里为零。

11
00:00:39,930 --> 00:00:43,135
现在，我们需要确定 x 加 y 是否是三的倍数。

12
00:00:43,135 --> 00:00:47,790
确实如此，所以我们进入 if 语句并在零、零处放一个蓝色方块。

13
00:00:47,790 --> 00:00:50,580
现在，y 的迭代没有更多的步骤，

14
00:00:50,580 --> 00:00:52,935
所以我们继续计数 y 等于 1。

15
00:00:52,935 --> 00:00:55,495
零加一不是三的倍数，

16
00:00:55,495 --> 00:00:59,700
所以我们输入其他子句并在零、一处放一个红方块。

17
00:00:59,700 --> 00:01:01,545
这个 y 没有其他步骤，

18
00:01:01,545 --> 00:01:03,450
所以我们将计算下一个步骤。

19
00:01:03,450 --> 00:01:05,665
零加二不是三的倍数，

20
00:01:05,665 --> 00:01:08,100
所以我们要在零、二处放一个红方块。

21
00:01:08,100 --> 00:01:10,345
我们继续计数，y 等于三。

22
00:01:10,345 --> 00:01:15,065
但是我们只是从 x 到 N 进行计数，所以我们没有执行任何这些步骤。

23
00:01:15,065 --> 00:01:16,935
我们继续对 x 进行计数，

24
00:01:16,935 --> 00:01:18,470
所以现在，x 是 1。

25
00:01:18,470 --> 00:01:21,360
我们要从 1 到 N 数然后称之为 y。

26
00:01:21,360 --> 00:01:24,055
一加一不是三的倍数，

27
00:01:24,055 --> 00:01:26,190
所以我们在一、一处放一个红方块。

28
00:01:26,190 --> 00:01:30,105
递增 y，一加二是三的倍数，

29
00:01:30,105 --> 00:01:32,665
所以我们在一、二处放一个蓝色方块。

30
00:01:32,665 --> 00:01:34,120
我们已经完成了 y 的计

31
00:01:34,120 --> 00:01:36,375
数，所以接下来，我们计算下一个的 x。

32
00:01:36,375 --> 00:01:37,995
从二到二计数，

33
00:01:37,995 --> 00:01:40,130
二加二不是三的倍数，

34
00:01:40,130 --> 00:01:41,670
所以我们放一个红方块。

35
00:01:41,670 --> 00:01:43,155
我们完成了 y 的计数，

36
00:01:43,155 --> 00:01:45,460
所以我们对下一个 x 进行计数。

37
00:01:45,460 --> 00:01:50,120
我们已经完成了 x 的计数，因为我们只想计数到 N，也就是二。

38
00:01:50,120 --> 00:01:51,790
所以我们完成了计数，

39
00:01:51,790 --> 00:01:54,700
我们完成了这个算法的执行。

40
00:01:54,700 --> 00:01:57,495
我们已经完成了，我们找到了我们所期望的答案。

41
00:01:57,495 --> 00:01:58,770
我们可以说我们的算法

42
00:01:58,770 --> 00:02:00,955
至少适用于 N 等于 2。

43
00:02:00,955 --> 00:02:04,470
我们对自己的算法更有信心了，因为我们已经证明它

44
00:02:04,470 --> 00:02:09,720
对于至少一个 N 值是正确的，而这不是我们以前想出的。

45
00:02:09,720 --> 00:02:11,955
如果我们想更加自信，

46
00:02:11,955 --> 00:02:14,445
就必须对其进行更彻底的测试。

47
00:02:14,445 --> 00:02:17,850
与往常一样，测试无法证明它是正确的，

48
00:02:17,850 --> 00:02:21,000
它只会让我们越来越自信。