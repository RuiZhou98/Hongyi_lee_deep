在之前的视频中，我们仔细地写下了 手工处理特定案例时所遵循的步骤。 在本视频中，我们概括了寻找最近点的步骤。 看看我们的步骤，其中一些是相似的，但 我们需要让它们匹配。 每个彩色方框都包含相似的步骤。 首先是计算，然后是比较。 我们还有一些只有有时才做的步骤， 我们需要弄清楚我们在什么条件下执行这些步骤。 我们还有一些步骤只能在开头和结尾做， 我们需要对这些步骤中的数字进行概括。 因此，让我们做的第一件事就是让这些相似的东西相匹配。 为什么在这里计算 9 平方加 6 平方， 接下来计算 7 平方加上 -1 平方等等。 如果我们看一下我们的图片，9 来自 delta x，6 来自增量 y。 集合 S 中的点 10、5 和 1、-1、点 p 之间的差异。 所有这些其他数字也是如此， 点 s 和 p 之间的 x 和 y 差异。 所以我们可以重写所有这些步骤，让点 S1、 S2 等，直到 S6。当@@ 我们进入起始步骤时，我们将第一个点称为 s0。 程序员通常喜欢从 0 开始计数。 第一个替换给我们 s1 的 x-P 的 x 数量平方 + s1 的 y-P 的 y 数量平方，然后是整个事物的平方根。 现在，这个计算的结果并不总是10.82或7.07， 所以我们应该给它们起个名字，比如当前距离。 但是当我们这样做时， 我们必须跟踪每次使用这个数字并更新它们。 也就是说，如果我们将第一次出现的 10.82 更改为 currentDistance， 那么我们需要将这条线的当前距离与 8.06 进行比较。 但是其中一些数字是以其他方式使用的，因此 这些数字需要不同的名称。 在这里，我们将每次计算的值替换为 currentDistance。 请注意，只有 当当前距离较小时，我们才会更新最佳选择。 这意味着我们一定一直在跟踪 迄今为止的最佳距离，我们现在也需要对其进行更新。 现在，当当前距离较小时，我们会更新最佳距离， 我们可以使用最佳距离的值与将来的计算进行比较。 让我们来看看我们计算的第一个 8.06，并考虑它发生的其他地方。 可以像使用 S0 一样进行计算。 由于这是我们的第一次计算，它也可能是迄今为止最好的， 那么我们可以用 BestDistance 替换另一个实例，使步骤匹配。 为了继续概括，让我们来看看 最佳选择 2,7,8、-2 和 -3、-5 的重点。 这些都是我们正在研究的具体点，因此 我们可以用 S0、S2 和 S4 替换它们。 回想一下，我们只 是在当前距离较小时才更新最佳选择。 我们可以通过包括每次比较 当前距离和最佳距离的说明来使每个步骤都相同，但是 只有在当前距离较小时才更新最佳距离。 现在，我们对每个点都执行相同的步骤。 每个彩色盒子都与其他方块相同，唯一的不同 是我们要看的是什么，从S1、S2到S6。 这意味着我们可以将其表达为重复， 其中我们从 1 计数到 S 不包含的分数。 我们将计算的每个数字称为 i， 然后计算从 S 中第 ieth 点到 P 的距离。 如果当前距离小于最佳距离， 则我们会将最佳选择更新为 SI，将最佳距离更新为 SI，将最佳距离更新为当前距离。 我们没有改变开始或结束的步骤，但 我们应该将我们给出的观点概括为答案。 答案并不总是-3、-5。 我们为什么这么说？ 当我们完成计数时，答案是最佳选择，所以总的来说， 我们会给出最佳选择的答案。 我们唯一需要做的另一件事就是考虑一个极端情况。 如果 S 里面有 0 分怎么办？ 在这种情况下，我们会给出不存在答案的答案。 我们刚才研究的例子并未揭示这个极端情况，但 它本来是通过测试得出来的。 以 0 分为例， 我们在计算的第一步时会遇到问题。 因此，我们报告没有答案，请跳过所有其他步骤。 所以这是我们的算法。 你可以自己测试一下。 稍后，我们将学习如何将其转换为代码。