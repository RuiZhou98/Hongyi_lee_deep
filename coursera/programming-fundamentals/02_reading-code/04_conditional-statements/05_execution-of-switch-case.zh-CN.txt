在本视频中，我们将使用函数 g 执行代码，该函数包含 switch c ase 语句。 与往常一样，我们从 main 开头的执行箭头开始， 表示语句 a = g (10, 4);。 既然我们声明了 a，我们就为它做一个方框，然后我们为 函数 g 创建一个框架，然后在里面填充值 10 代表 n，用 4 表示 x。 我们记下自己的位置，然后返回到函数完成的时间， 然后输入函数 g。 在本例中，我们有 switch 语句 x + n 是 4 + 10，也就是 14。 因此，我们找到了匹配的 case 标签 case 14，然后将 执行箭头转移到该案例中，然后开始在那里执行语句。 我们遇到的第一条语句是返回语句 n-x，10-4 = 6。 与往常一样，当我们遇到 return 语句时， 我们将记下要返回的值，然后离开我们 要返回的函数返回到调用函数并销毁框架。 我们以 a = 6 结束了赋值语句。 现在我们到达 int b = g (a, 2)。 因此，我们为 b 创建一个方框，为 g 画一个框架，传入参数 a， 即 6 和 2。 我们记下我们的位置并输入函数 g。 在这里，我们的选择表达式是 2 + 6，也就是 8，所以 我们将深入研究 8 的案例并开始在那里执行语句。 我们遇到的第一条语句是 x = x + 1，因此 我们将 x 的框更新为 3 而不是 2。 现在我们来看下一个案例。 这里没有中断声明， 我们也不用担心还有另一个手机壳标签。 我们只是继续执行语句，直到休息一下。 下一个语句是 n = n-1。 因此，我们要将 n 的值更新为 5。 现在我们确实达成了休息声明。 这个 break 语句将使我们脱离最内层 封闭的 switch 语句，即这里的边界。 正如我们稍后将看到的，break 可能会使我们退出其他结构。 但是在这种情况下，它将使我们退出包含它的 switch 语句，然后 我们在切换之后开始执行代码。 我们遇到的下一个语句是返回 x * n，即 3 * 5，也就是 15。 所以我们返回 15，返回 main，然后 销毁 g 的帧然后将 15 分配给 b。 现在我们有 int c = g (9, b)。 因此，我们为 c 创建一个方框，为 g 创建一个框架，参数为 9， b 为 15，然后记下我们在哪里，然后输入函数 g。 计算这个表达式会得到 24。 查看我们的箱子标签，我们有 8、0 和 14。 这些都不匹配 24，因此我们使用默认值，它匹配任何未 被其他案例标签明确命名的内容。 我们将跳入默认情况并开始在那里执行语句。 我们做 x = n，将 9 分配给 x，这使我们陷入了中断， 这使我们脱离了 switch 语句的内部。 我们现在返回 x * n，即 81。 回到 main，我们完成任务并从 main 退出程序时返回零。