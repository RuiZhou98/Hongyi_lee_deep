1
00:00:02,260 --> 00:00:06,485
接下来你要学习的C部分是函数。

2
00:00:06,485 --> 00:00:08,640
要了解它们为何如此重要，

3
00:00:08,640 --> 00:00:11,630
让我们回顾一下我们的 ClosestPoint 算法。

4
00:00:11,630 --> 00:00:15,920
这里有两个地方使用此算法计算两点之间的距离。

5
00:00:15,920 --> 00:00:17,195
为什么这很重要？

6
00:00:17,195 --> 00:00:20,075
好吧，我们需要进行两次相同的计算。

7
00:00:20,075 --> 00:00:25,535
如果没有函数，我们会写两次相同的代码，而这仅仅是这个问题。

8
00:00:25,535 --> 00:00:30,340
如果我们还有其他问题需要计算两点之间的距离怎么办？

9
00:00:30,340 --> 00:00:33,080
我们有几个其他问题的例子，

10
00:00:33,080 --> 00:00:35,860
需要计算两点之间的距离，

11
00:00:35,860 --> 00:00:37,565
但还有很多其他问题。

12
00:00:37,565 --> 00:00:39,935
我们可以每次都重写代码，对于

13
00:00:39,935 --> 00:00:44,000
像计算

14
00:00:44,000 --> 00:00:49,110
距离这样小的事情来说，这似乎没什么大不了的，但我们希望尽可能避免重复代码。

15
00:00:49,110 --> 00:00:50,825
每次我们重写代码时，

16
00:00:50,825 --> 00:00:56,210
我们都会冒着犯错误和在程序中引入错误的风险。

17
00:00:56,210 --> 00:01:01,010
此外，一次又一次地重写同样的代码真的很无聊。

18
00:01:01,010 --> 00:01:06,530
相反，我们应该将距离的计算抽象成一个自己的函数。将@@

19
00:01:06,530 --> 00:01:10,010
距离设为自己的函数意味着我们可以在

20
00:01:10,010 --> 00:01:14,740
任何需要的地方重复使用该算法，而无需重写它。这将如何运作？

21
00:01:14,740 --> 00:01:16,835
好吧，我们的 ClosestPoint 函数将在

22
00:01:16,835 --> 00:01:19,450
其代码中调用距离函数。

23
00:01:19,450 --> 00:01:23,990
也就是说，它将要求距离函数执行其计算。

24
00:01:23,990 --> 00:01:28,250
为此，我们的 ClosestPoint 函数将首先传入

25
00:01:28,250 --> 00:01:32,930
参数值，指定距离函数应在哪些点上进行计算。

26
00:01:32,930 --> 00:01:35,525
距离函数将执行其代码，

27
00:01:35,525 --> 00:01:39,255
根据你正在学习的规则执行其中的任何语句。

28
00:01:39,255 --> 00:01:40,850
当它得出

29
00:01:40,850 --> 00:01:44,330
一个答案并返回到调用它的函数时，它就结束了。

30
00:01:44,330 --> 00:01:47,400
当它返回时，距离函数就完成了

31
00:01:47,400 --> 00:01:50,705
，调用函数会继续自己执行，

32
00:01:50,705 --> 00:01:54,180
使用它从调用的函数中得到的答案。

33
00:01:54,180 --> 00:01:56,085
那么，这有什么帮助呢？

34
00:01:56,085 --> 00:02:00,470
首先，我们可以随时重复使用这种距离计算。

35
00:02:00,470 --> 00:02:02,105
我们不必重写它。

36
00:02:02,105 --> 00:02:06,845
我们可以调用距离函数来计算任意两点之间的距离。

37
00:02:06,845 --> 00:02:10,310
无论我们需要计算C

38
00:02:10,310 --> 00:02:12,230
losestPoint函数中不同位置的距离，还是在我们要

39
00:02:12,230 --> 00:02:17,165
解决的其他问题中计算距离都无关紧要，我们只需要称之为即可。

40
00:02:17,165 --> 00:02:21,170
函数的另一个重要好处是抽象。

41
00:02:21,170 --> 00:02:24,035
抽象是将接口（

42
00:02:24,035 --> 00:02:25,625
意思是某物所做的事情）与

43
00:02:25,625 --> 00:02:29,115
其实现的分离，即它是如何实现的。

44
00:02:29,115 --> 00:02:31,280
一旦我们编写了距离函数，

45
00:02:31,280 --> 00:02:35,410
我们就可以在不考虑其内部工作原理的情况下使用它。

46
00:02:35,410 --> 00:02:37,970
随着你构建越来越大的程序，

47
00:02:37,970 --> 00:02:40,955
抽象变得越来越重要。

48
00:02:40,955 --> 00:02:43,685
您也不局限于两个功能。

49
00:02:43,685 --> 00:02:48,435
你可以有许多函数，它们可以根据需要调用任意数量的其他函数。

50
00:02:48,435 --> 00:02:53,285
例如，假设我们的 ClosestPoint 函数是一个更大的程序的一部分，

51
00:02:53,285 --> 00:02:56,780
该程序包含有关各种类型位置

52
00:02:56,780 --> 00:03:01,230
的信息，并使用这些信息为我们提供特定类型的最近位置。

53
00:03:01,230 --> 00:03:03,225
你最终可能会得到这样的结果。

54
00:03:03,225 --> 00:03:06,320
主函数是所有 C 程序的起点，它

55
00:03:06,320 --> 00:03:11,321
可能会调用一个函数来查找最近的商店点 42,17，并

56
00:03:11,321 --> 00:03:14,510
传入参数来指定此信息。

57
00:03:14,510 --> 00:03:20,170
然后，该函数可能会调用另一个函数来查找所有类型为 store 的位置。然后

58
00:03:20,170 --> 00:03:23,390
，getByType 函数可以返回

59
00:03:23,390 --> 00:03:26,705
商店的位置列表，然后 findNearest 可以使用。

60
00:03:26,705 --> 00:03:30,275
然后，findNearest 可以调用另一个函数（

61
00:03:30,275 --> 00:03:34,760
例如我们的 ClosestPoint 函数）来找到离我们想要的位置最近的点。

62
00:03:34,760 --> 00:03:36,675
正如我们之前所讨论的，C

63
00:03:36,675 --> 00:03:39,710
losestPoint可以调用距离来计算

64
00:03:39,710 --> 00:03:43,610
两点之间的距离，它将返回计算出的距离。

65
00:03:43,610 --> 00:03:46,250
当然，对于ClosestPoint来说，

66
00:03:46,250 --> 00:03:49,115
根据需要多次呼叫距离，

67
00:03:49,115 --> 00:03:52,115
无论传入什么分数都能得到答案，这是完全可以的。

68
00:03:52,115 --> 00:03:56,670
当 ClosestPoint 完成计算并找出答案时，

69
00:03:56,670 --> 00:04:00,200
它会将该值返回给调用

70
00:04:00,200 --> 00:04:04,655
它的函数，然后该函数完成计算并将其答案返回给调用它的函数。

71
00:04:04,655 --> 00:04:06,255
好吧，太棒了。

72
00:04:06,255 --> 00:04:08,890
现在，你有了函数的高级概念。

73
00:04:08,890 --> 00:04:12,860
让我们在 C 语言中深入研究它们的语法和语义