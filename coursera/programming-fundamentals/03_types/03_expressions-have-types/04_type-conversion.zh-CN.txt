让我们来看一些示例代码，这些代码显示了隐式转换何时发生， 以及如何谨慎对待类型。 首先，我们创建一个名为 NHR 的整数并将其初始化为 40。 接下来，我们创作 nDays 并将其初始化为 7。 接下来，我们有一个名为平均值的浮点数， 它被初始化为 nHours 除以 nDays。 nHours 和 nDays 都是整数，所以这是整数除法。 我们有 40 除以七 ，对于整数除法，则得出五。 现在，由于我们要为浮点数赋值 int， 编译器会将该整数结果隐式转换为浮点数。 但是它是在除法之后这样做的， 所以我们最终将平均值初始化为5.0。 然后我们打印出 7 天内 40 小时等于每天 5.0 小时。 这不是正确的答案， 所以让我们修复这段代码。 在这里，我们对代码做了一个小改动。在@@ 进行除法之前，我们已经明确将 nDay s 转换为浮点数，此处用红色下划线标出。 我们以同样的方式开始， nHours 被创建并初始化为 40， nDays 被创建并初始化为 7。 但是，现在情况有所不同。 这个表达式的除数现在是七转换为浮点数， 所以我们需要计算整数 40 除以浮点数 7.0。 计算机将整数除以整数 或将浮点数除以浮点数， 因此编译器在进行除法 之前必须将 40 隐式转换为浮点数。 现在我们正在进行浮点除法， 14.0 除以 7.0 等于 5.71。 现在，我们用这个值初始化平均值，这意味着当我们打印出结果时， 我们会得到正确的答案。 现在你已经看到了隐式转换和显式转换。 当你需要时，你可以使用铸造。 但是， 只有当你仔细考虑要在什么之间进行转换以及为什么要转换时，才应该谨慎使用它。