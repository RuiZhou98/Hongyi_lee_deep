In this video, we are going to execute some calls to printf using a variety of format specifiers so you can see how to print types other than int. First, we initialize a char letter to be G and int negNumber to be -1, and an unsigned int age to be 33. Next, we come to a print statement. Printf will look for any format specifiers and in this case, it has a %c telling printf to look at the next argument and format it as a character. It prints, my name begins with G. The next statement has the familiar %d and we've seen before that it will print negNumber as a decimal integer. The next statement prints the value of age as a decimal integer, but the next statement uses the %o format specifier telling printf to print the value of age in octal or base eight. The final statement has a %x telling printf to print the value of age as a hexadecimal or base 16 integer. What if we change things around a bit and use format specifiers that seems strange for the types of data we are passing it? We start the same way, but now our print statement uses %d to format letter. What will happen? Well, remember that everything is a number. Letter actually has a numerical value which is 71. This numerical value is what actually gets passed to printf. Printf has no idea that the 71 value it receives is originally from a char so it just prints 71. Next, we print negNumber which is -1 as a hexadecimal number. If you work out how negative one is represented with a 32-bit signed integer, you will find the hex value is ffffffff. Our next statement uses %u which formats an integer as an unsigned decimal number. But we are passing in negNumber, so what will happen? Remember that everything is just a bunch of bits to the computer. If you take the binary representation of -1, which is 32 ones, and interpret it as an unsigned 32-bit integer, you get the largest possible 32-bit unsigned integer, which is about 4.2 billion. Our last print statement uses %c to format the integer age. What happens here? Well again, everything is just a number, so printf will print out the character whose numeric representation is 33, which is the exclamation mark character. What if we work with floating point numbers instead? Here are some more printf calls that use floats and doubles. p1 is a float, 3.141592, and p2 is a double that contains more digits of pi. The first call to printf uses the %f format specifier to print p1 as a floating point number. The next call has a %e, which means print p1 in scientific notation. Note the e+00, which means times ten to the zeroth power or times one. If we were to print 100 pi using scientific notation, we would get e+02 for times 10 to the second power. Next, we have the format specifier %.10f. The .10 between the percent and the f means to print 10 decimal places. When we do this, we get a slightly odd answer. Where did this 0258 come from? This comes from the fact that floating point numbers can't represent every possible number precisely. C rounded 3.141592 to the nearest representable floating point number when it performed the initialization of p1. When we print p1, it converts that number which is actually stored in p1 to a decimal representation. If that is confusing, it is okay for now since we will not do much with floating point. But if you find yourself writing real programs with floating point, you need to understand how all of this works to avoid subtle and dangerous problems. Next, we print p2 with the default formatting for a double, which prints six digits after the decimal, rounding the last one. Our next printf prints p2 with 10 digits after the decimal. Here, they are all what we expect. Why is this different? Doubles can represent more numbers more precisely than floats can, so the inaccuracies of representing this number do not appear in these 10 digits.