1
00:00:02,320 --> 00:00:07,040
在本视频中，我们将使用

2
00:00:07,040 --> 00:00:11,465
各种格式说明符对 printf 执行一些调用，这样你就可以看到如何打印 int 以外的类型。

3
00:00:11,465 --> 00:00:16,595
首先，我们将字符字母初始化为 G，int negNumber 初始化为 -1，将

4
00:00:16,595 --> 00:00:19,835
无符号整数初始化为 33。

5
00:00:19,835 --> 00:00:21,435
接下来，我们来看一份印刷声明。

6
00:00:21,435 --> 00:00:24,380
Printf 将查找任何格式说明符，在本例中，

7
00:00:24,380 --> 00:00:29,135
它有一个 %c 告诉 printf 查看下一个参数并将其格式化为字符。

8
00:00:29,135 --> 00:00:32,610
它会打印，我的名字以 G 开头。下一条语句有

9
00:00:32,610 --> 00:00:37,945
熟悉的 %d，我们之前已经看到它会将 negNumber 打印为十进制整数。

10
00:00:37,945 --> 00:00:41,594
下一个语句将 age 的值打印为十进制整数，

11
00:00:41,594 --> 00:00:43,100
但下一个语句使用

12
00:00:43,100 --> 00:00:49,805
%o 格式说明符告诉 printf 以八进制或八进制打印年龄的值。

13
00:00:49,805 --> 00:00:53,270
最后一条语句有一个 %x 告诉 printf 将

14
00:00:53,270 --> 00:00:57,570
age 的值打印为十六进制或以 16 为基数的整数。

15
00:00:57,570 --> 00:01:00,410
如果我们稍微改变一下然后使用

16
00:01:00,410 --> 00:01:04,820
对于我们传递的数据类型来说看起来很奇怪的格式说明符，该怎么办？

17
00:01:04,820 --> 00:01:07,733
我们以同样的方式开始，

18
00:01:07,733 --> 00:01:13,140
但是现在我们的打印语句使用 %d 来格式化信件。会发生什么？

19
00:01:13,140 --> 00:01:15,355
好吧，请记住，一切都是数字。

20
00:01:15,355 --> 00:01:19,240
字母的数值实际上是 71。

21
00:01:19,240 --> 00:01:21,985
这个数值实际上是传递给 printf 的值。

22
00:01:21,985 --> 00:01:25,150
Printf 不知道

23
00:01:25,150 --> 00:01:28,965
它收到的 71 值最初来自一个字符，所以它只打印 71。

24
00:01:28,965 --> 00:01:33,320
接下来，我们将为 -1 的 negNumber 打印为十六进制数。

25
00:01:33,320 --> 00:01:37,495
如果你计算出 32 位有符号整数如何表示负数，

26
00:01:37,495 --> 00:01:42,710
你会发现十六进制值是 fffffffff。

27
00:01:42,710 --> 00:01:47,100
我们的下一个语句使用 %u，它将整数格式化为无符号的十进制数。

28
00:01:47,100 --> 00:01:48,763
但是我们正在传递 negNumber，

29
00:01:48,763 --> 00:01:49,910
那么会发生什么？

30
00:01:49,910 --> 00:01:52,990
请记住，对于计算机来说，一切都只是一堆碎片。

31
00:01:52,990 --> 00:01:55,945
如果你取-1的二进制表示形式，

32
00:01:55,945 --> 00:01:57,415
也就是32个一，

33
00:01:57,415 --> 00:02:00,505
然后将其解释为一个无符号的32位整数，

34
00:02:00,505 --> 00:02:03,940
你就会得到可能的最大32位无符号整数，约

35
00:02:03,940 --> 00:02:06,025
为42亿。

36
00:02:06,025 --> 00:02:11,380
我们的最后一个打印语句使用 %c 来格式化整数年龄。这里会发生什么？

37
00:02:11,380 --> 00:02:13,380
再说一遍，一切都只是一个数字，

38
00:02:13,380 --> 00:02:17,770
所以 printf 将打印出数字表示形式为 33 的字符，

39
00:02:17,770 --> 00:02:20,910
即感叹号字符。

40
00:02:20,910 --> 00:02:24,425
如果我们改用浮点数呢？

41
00:02:24,425 --> 00:02:28,285
以下是更多使用浮点数和双精度数的 printf 调用。

42
00:02:28,285 --> 00:02:30,284
p1 是浮点数，

43
00:02:30,284 --> 00:02:35,425
3.141592，p2 是包含更多位数 pi 的双精度。

44
00:02:35,425 --> 00:02:37,150
对 printf

45
00:02:37,150 --> 00:02:41,720
的第一次调用使用 %f 格式说明符将 p1 打印为浮点数。

46
00:02:41,720 --> 00:02:43,098
下一个调用有一个 %e，

47
00:02:43,098 --> 00:02:46,780
这意味着用科学计数法打印 p1。

48
00:02:46,780 --> 00:02:51,545
请注意 e+00，这意味着乘以零次方或乘以一。

49
00:02:51,545 --> 00:02:54,175
如果我们使用科学计数法打印 100 pi，则

50
00:02:54,175 --> 00:02:58,270
将乘以 10 的次方得到 e+02。

51
00:02:58,270 --> 00:03:01,285
接下来，我们有格式说明符 %.10f。

52
00:03:01,285 --> 00:03:05,410
百分比和 f 之间的.10 表示打印 10 位小数。

53
00:03:05,410 --> 00:03:08,265
当我们这样做时，我们会得到一个有点奇怪的答案。

54
00:03:08,265 --> 00:03:10,870
这个 0258 是从哪里来的？

55
00:03:10,870 --> 00:03:13,480
这源于这样一个事实，即浮点数

56
00:03:13,480 --> 00:03:16,650
无法精确地表示所有可能的数字。

57
00:03:16,650 --> 00:03:20,590
C 在

58
00:03:23,065 --> 00:03:26,335
执行 p1 的初始化时将 3.141592 四舍五入到最接近的可表示浮点数。

59
00:03:26,335 --> 00:03:29,455
当我们打印 p1 时，它会将

60
00:03:29,455 --> 00:03:33,230
实际存储在 p1 中的数字转换为十进制表示形式。

61
00:03:33,230 --> 00:03:34,435
如果这令人困惑，

62
00:03:34,435 --> 00:03:37,565
那么现在还可以，因为我们不会对浮点进行太多处理。

63
00:03:37,565 --> 00:03:40,615
但是，如果你发现自己用浮点写真实的程序，

64
00:03:40,615 --> 00:03:46,000
你需要了解所有这些是如何工作的，以避免出现微妙和危险的问题。

65
00:03:46,000 --> 00:03:49,750
接下来，我们使用默认的双

66
00:03:49,750 --> 00:03:52,403
精度格式打印 p2，即在小数点后打印六位数字，将

67
00:03:52,403 --> 00:03:54,380
最后一个数字四舍五入。

68
00:03:54,380 --> 00:03:58,030
我们的下一个 printf 打印的是小数点后面有 10 位数的 p2。

69
00:03:58,030 --> 00:04:00,065
在这里，它们都是我们所期望的。

70
00:04:00,065 --> 00:04:01,590
这有什么不同？

71
00:04:01,590 --> 00:04:05,320
双数可以比浮点数更精确地表示更多的数字，

72
00:04:05,320 --> 00:04:10,730
因此表示这个数字的不准确之处不会出现在这 10 位数字中。