在本视频中，我们将使用 各种格式说明符对 printf 执行一些调用，这样你就可以看到如何打印 int 以外的类型。 首先，我们将字符字母初始化为 G，int negNumber 初始化为 -1，将 无符号整数初始化为 33。 接下来，我们来看一份印刷声明。 Printf 将查找任何格式说明符，在本例中， 它有一个 %c 告诉 printf 查看下一个参数并将其格式化为字符。 它会打印，我的名字以 G 开头。下一条语句有 熟悉的 %d，我们之前已经看到它会将 negNumber 打印为十进制整数。 下一个语句将 age 的值打印为十进制整数， 但下一个语句使用 %o 格式说明符告诉 printf 以八进制或八进制打印年龄的值。 最后一条语句有一个 %x 告诉 printf 将 age 的值打印为十六进制或以 16 为基数的整数。 如果我们稍微改变一下然后使用 对于我们传递的数据类型来说看起来很奇怪的格式说明符，该怎么办？ 我们以同样的方式开始， 但是现在我们的打印语句使用 %d 来格式化信件。会发生什么？ 好吧，请记住，一切都是数字。 字母的数值实际上是 71。 这个数值实际上是传递给 printf 的值。 Printf 不知道 它收到的 71 值最初来自一个字符，所以它只打印 71。 接下来，我们将为 -1 的 negNumber 打印为十六进制数。 如果你计算出 32 位有符号整数如何表示负数， 你会发现十六进制值是 fffffffff。 我们的下一个语句使用 %u，它将整数格式化为无符号的十进制数。 但是我们正在传递 negNumber， 那么会发生什么？ 请记住，对于计算机来说，一切都只是一堆碎片。 如果你取-1的二进制表示形式， 也就是32个一， 然后将其解释为一个无符号的32位整数， 你就会得到可能的最大32位无符号整数，约 为42亿。 我们的最后一个打印语句使用 %c 来格式化整数年龄。这里会发生什么？ 再说一遍，一切都只是一个数字， 所以 printf 将打印出数字表示形式为 33 的字符， 即感叹号字符。 如果我们改用浮点数呢？ 以下是更多使用浮点数和双精度数的 printf 调用。 p1 是浮点数， 3.141592，p2 是包含更多位数 pi 的双精度。 对 printf 的第一次调用使用 %f 格式说明符将 p1 打印为浮点数。 下一个调用有一个 %e， 这意味着用科学计数法打印 p1。 请注意 e+00，这意味着乘以零次方或乘以一。 如果我们使用科学计数法打印 100 pi，则 将乘以 10 的次方得到 e+02。 接下来，我们有格式说明符 %.10f。 百分比和 f 之间的.10 表示打印 10 位小数。 当我们这样做时，我们会得到一个有点奇怪的答案。 这个 0258 是从哪里来的？ 这源于这样一个事实，即浮点数 无法精确地表示所有可能的数字。 C 在 执行 p1 的初始化时将 3.141592 四舍五入到最接近的可表示浮点数。 当我们打印 p1 时，它会将 实际存储在 p1 中的数字转换为十进制表示形式。 如果这令人困惑， 那么现在还可以，因为我们不会对浮点进行太多处理。 但是，如果你发现自己用浮点写真实的程序， 你需要了解所有这些是如何工作的，以避免出现微妙和危险的问题。 接下来，我们使用默认的双 精度格式打印 p2，即在小数点后打印六位数字，将 最后一个数字四舍五入。 我们的下一个 printf 打印的是小数点后面有 10 位数的 p2。 在这里，它们都是我们所期望的。 这有什么不同？ 双数可以比浮点数更精确地表示更多的数字， 因此表示这个数字的不准确之处不会出现在这 10 位数字中。