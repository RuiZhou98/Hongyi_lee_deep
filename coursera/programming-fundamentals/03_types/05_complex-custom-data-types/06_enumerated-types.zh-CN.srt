1
00:00:02,680 --> 00:00:08,000
现在我们将向你展示如何定义和使用你自己的枚举类型。

2
00:00:08,000 --> 00:00:09,610
在屏幕顶部，

3
00:00:09,610 --> 00:00:13,820
我们采用标准安全系统的颜色编码的威胁级别，

4
00:00:13,820 --> 00:00:16,850
并编码为枚举类型。

5
00:00:16,850 --> 00:00:18,680
有五个可能的级别。

6
00:00:18,680 --> 00:00:23,420
低、防守、升高、高和严重。

7
00:00:23,420 --> 00:00:28,340
我们可以在整个代码中使用这些单词来引用这些级别。

8
00:00:28,340 --> 00:00:32,860
接下来，有两个辅助函数，我们稍后将向您展示其定义。

9
00:00:32,860 --> 00:00:35,455
第一个函数是 PrintThreat，

10
00:00:35,455 --> 00:00:39,855
它打印与特定枚举类型关联的字符串。

11
00:00:39,855 --> 00:00:42,095
第二个功能是PrintShoes，

12
00:00:42,095 --> 00:00:44,630
它可以打印在

13
00:00:44,630 --> 00:00:48,130
当前威胁等级下是否要求一个人脱鞋。

14
00:00:48,130 --> 00:00:50,948
我们的主函数，初始化威胁等级，

15
00:00:50,948 --> 00:00:55,365
将其打印出来，然后调用这两个辅助函数。

16
00:00:55,365 --> 00:00:57,995
让我们仔细看看我们的枚举类型。

17
00:00:57,995 --> 00:01:03,520
C 在每个单词和一个整数值之间创建对应关系。

18
00:01:03,520 --> 00:01:05,645
因此，低值的值为 0

19
00:01:05,645 --> 00:01:08,575
，严重值为 4。

20
00:01:08,575 --> 00:01:11,300
请注意，函数 PrintThreat 如何在

21
00:01:11,300 --> 00:01:14,930
整个定义中使用这些单词来指代这些级别，这

22
00:01:14,930 --> 00:01:17,675
使得代码更易于阅读，

23
00:01:17,675 --> 00:01:21,370
PrintShoes 也可以做到这一点。在@@

24
00:01:21,370 --> 00:01:28,680
主体中，我们声明了一个名为 MyThreat 的威胁等级 T 的新变量。

25
00:01:28,680 --> 00:01:30,780
我们将这个变量初始化为枚举 HI

26
00:01:30,780 --> 00:01:33,645
GH，它的整数值为 3。

27
00:01:33,645 --> 00:01:36,285
为了打印出当前的威胁级别，

28
00:01:36,285 --> 00:01:38,720
我们将函数称为 PrintThreat。

29
00:01:38,720 --> 00:01:42,360
我们为 PrintThreat 创建了一个堆栈框架，其中

30
00:01:42,360 --> 00:01:45,810
将参数 myThreat 称为威胁。

31
00:01:45,810 --> 00:01:49,725
我们标记呼叫地点位置并进入打印威胁。

32
00:01:49,725 --> 00:01:53,280
在 print threat 中，有一个 switch 语句可以检查

33
00:01:53,280 --> 00:01:57,015
威胁的价值并跳转到相应的案例。

34
00:01:57,015 --> 00:01:59,730
在这里，我们跳到了案例高位。

35
00:01:59,730 --> 00:02:01,570
在本例中，

36
00:02:01,570 --> 00:02:08,250
我们打印 Orange/High，中断使我们退出了 switch 语句。

37
00:02:08,250 --> 00:02:11,830
现在我们回到名为 PrintThreat 的函数，这是我们的主函数。

38
00:02:11,830 --> 00:02:16,235
返回后，PrintThreat 的堆栈帧将被销毁。

39
00:02:16,235 --> 00:02:18,668
接下来，我们执行对 PrintShoes 的调用，

40
00:02:18,668 --> 00:02:21,040
为打印鞋创建一个堆栈框架，

41
00:02:21,040 --> 00:02:22,775
其中参数 myThreat

42
00:02:22,775 --> 00:02:25,200
被称为 currThreat。

43
00:02:25,200 --> 00:02:26,950
我们标记呼叫地点的位置，

44
00:02:26,950 --> 00:02:29,235
然后进入印花鞋。

45
00:02:29,235 --> 00:02:32,830
在 PrintShoes 中，有一个 if/else 语句。

46
00:02:32,830 --> 00:02:37,960
if 子句用于测试当前威胁是否大于或等于已升级。

47
00:02:37,960 --> 00:02:41,935
在本例中，我们正在测试 3 是否大于或等于 2。

48
00:02:41,935 --> 00:02:45,075
既然如此，我们进入了 then 条款，

49
00:02:45,075 --> 00:02:46,405
打印出消息，

50
00:02:46,405 --> 00:02:48,055
请脱鞋，

51
00:02:48,055 --> 00:02:50,430
然后退出该条款。

52
00:02:50,430 --> 00:02:54,850
现在我们回到名为 print shoes 的函数，这是我们的主函数。

53
00:02:54,850 --> 00:02:59,140
返回后，印花鞋的堆叠框架被销毁。

54
00:02:59,140 --> 00:03:01,275
最后，程序退出主节点

55
00:03:01,275 --> 00:03:04,115
，其堆栈帧被销毁。

56
00:03:04,115 --> 00:03:09,100
请注意，由于我们使用了枚举类型，因此代码更容易阅读。

57
00:03:09,100 --> 00:03:11,037
相反，我们有一个名为 t

58
00:03:11,037 --> 00:03:13,745
hreat_level 的整数，其值为 0 到 4。

59
00:03:13,745 --> 00:03:15,910
代码中会充斥着很多数字，

60
00:03:15,910 --> 00:03:18,605
读者可能不清楚其含义。

61
00:03:18,605 --> 00:03:20,995
枚举类型使读取

62
00:03:20,995 --> 00:03:24,000
、编写和修改代码变得更加容易。