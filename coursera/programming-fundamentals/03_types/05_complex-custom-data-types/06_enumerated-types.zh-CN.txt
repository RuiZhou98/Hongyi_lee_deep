现在我们将向你展示如何定义和使用你自己的枚举类型。 在屏幕顶部， 我们采用标准安全系统的颜色编码的威胁级别， 并编码为枚举类型。 有五个可能的级别。 低、防守、升高、高和严重。 我们可以在整个代码中使用这些单词来引用这些级别。 接下来，有两个辅助函数，我们稍后将向您展示其定义。 第一个函数是 PrintThreat， 它打印与特定枚举类型关联的字符串。 第二个功能是PrintShoes， 它可以打印在 当前威胁等级下是否要求一个人脱鞋。 我们的主函数，初始化威胁等级， 将其打印出来，然后调用这两个辅助函数。 让我们仔细看看我们的枚举类型。 C 在每个单词和一个整数值之间创建对应关系。 因此，低值的值为 0 ，严重值为 4。 请注意，函数 PrintThreat 如何在 整个定义中使用这些单词来指代这些级别，这 使得代码更易于阅读， PrintShoes 也可以做到这一点。在@@ 主体中，我们声明了一个名为 MyThreat 的威胁等级 T 的新变量。 我们将这个变量初始化为枚举 HI GH，它的整数值为 3。 为了打印出当前的威胁级别， 我们将函数称为 PrintThreat。 我们为 PrintThreat 创建了一个堆栈框架，其中 将参数 myThreat 称为威胁。 我们标记呼叫地点位置并进入打印威胁。 在 print threat 中，有一个 switch 语句可以检查 威胁的价值并跳转到相应的案例。 在这里，我们跳到了案例高位。 在本例中， 我们打印 Orange/High，中断使我们退出了 switch 语句。 现在我们回到名为 PrintThreat 的函数，这是我们的主函数。 返回后，PrintThreat 的堆栈帧将被销毁。 接下来，我们执行对 PrintShoes 的调用， 为打印鞋创建一个堆栈框架， 其中参数 myThreat 被称为 currThreat。 我们标记呼叫地点的位置， 然后进入印花鞋。 在 PrintShoes 中，有一个 if/else 语句。 if 子句用于测试当前威胁是否大于或等于已升级。 在本例中，我们正在测试 3 是否大于或等于 2。 既然如此，我们进入了 then 条款， 打印出消息， 请脱鞋， 然后退出该条款。 现在我们回到名为 print shoes 的函数，这是我们的主函数。 返回后，印花鞋的堆叠框架被销毁。 最后，程序退出主节点 ，其堆栈帧被销毁。 请注意，由于我们使用了枚举类型，因此代码更容易阅读。 相反，我们有一个名为 t hreat_level 的整数，其值为 0 到 4。 代码中会充斥着很多数字， 读者可能不清楚其含义。 枚举类型使读取 、编写和修改代码变得更加容易。